"use strict";
var $foreign = require("./foreign");
var Prelude = require("../Prelude");
var Control_Monad_Eff = require("../Control.Monad.Eff");
var Control_Monad_Eff_Timer = require("../Control.Monad.Eff.Timer");
var Signal = require("../Signal");
var Data_Eq = require("../Data.Eq");
var Data_Function = require("../Data.Function");

/**
 *  |Takes a signal and a time value, and creates a signal which yields `True`
 *  |when the input signal yields, then goes back to `False` after the given
 *  |number of milliseconds have elapsed, unless the input signal yields again
 *  |in the interim.
 */
var since = $foreign.sinceP(Signal.constant);
var second = 1000.0;
var millisecond = 1.0;

/**
 *  |Creates a signal which yields the current time (according to `now`) every
 *  |given number of milliseconds.
 */
var every = $foreign.everyP(Signal.constant);

/**
 *  |Takes a signal and delays its yielded values by a given number of
 *  |milliseconds.
 */
var delay = $foreign.delayP(Signal.constant);

/**
 *  |Takes a signal and a time value, and creates a signal which waits to yield
 *  |the next result until the specified amount of time has elapsed. It then
 *  |yields only the newest value from that period. New events during the debounce
 *  |period reset the delay.
 */
var debounce = function (t) {
    return function (s) {
        var whenEqual = function (value) {
            return function (input) {
                return Signal.filter(Data_Eq.eq(Data_Eq.eqBoolean)(value))(value)(input);
            };
        };
        var whenChangeTo = function (value) {
            return function (input) {
                return whenEqual(value)(Signal.dropRepeats(Data_Eq.eqBoolean)(input));
            };
        };
        var leading = whenChangeTo(false)(since(t)(s));
        return Signal.sampleOn(leading)(s);
    };
};
module.exports = {
    debounce: debounce, 
    delay: delay, 
    every: every, 
    millisecond: millisecond, 
    second: second, 
    since: since, 
    now: $foreign.now
};
