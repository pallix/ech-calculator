"use strict";
var Prelude = require("../Prelude");
var Data_Either = require("../Data.Either");
var Data_Profunctor = require("../Data.Profunctor");
var Data_Function = require("../Data.Function");
var Data_Functor = require("../Data.Functor");
var Control_Semigroupoid = require("../Control.Semigroupoid");
var Control_Category = require("../Control.Category");

/**
 *  | The `Choice` class extends `Profunctor` with combinators for working with
 *  | sum types.
 *  |
 *  | `left` and `right` lift values in a `Profunctor` to act on the `Left` and
 *  | `Right` components of a sum, respectively.
 *  |
 *  | Looking at `Choice` through the intuition of inputs and outputs
 *  | yields the following type signature:
 *  | ```
 *  | left ::  forall input output a. p input output -> p (Either input a) (Either output a)
 *  | right :: forall input output a. p input output -> p (Either a input) (Either a output)
 *  | ```
 *  | If we specialize the profunctor `p` to the `function` arrow, we get the following type
 *  | signatures:
 *  | ```
 *  | left ::  forall input output a. (input -> output) -> (Either input a) -> (Either output a)
 *  | right :: forall input output a. (input -> output) -> (Either a input) -> (Either a output)
 *  | ```
 *  | When the `profunctor` is `Function` application, `left` allows you to map a function over the
 *  | left side of an `Either`, and `right` maps it over the right side (same as `map` would do).
 */
var Choice = function (__superclass_Data$dotProfunctor$dotProfunctor_0, left, right) {
    this["__superclass_Data.Profunctor.Profunctor_0"] = __superclass_Data$dotProfunctor$dotProfunctor_0;
    this.left = left;
    this.right = right;
};

/**
 *  | The `Choice` class extends `Profunctor` with combinators for working with
 *  | sum types.
 *  |
 *  | `left` and `right` lift values in a `Profunctor` to act on the `Left` and
 *  | `Right` components of a sum, respectively.
 *  |
 *  | Looking at `Choice` through the intuition of inputs and outputs
 *  | yields the following type signature:
 *  | ```
 *  | left ::  forall input output a. p input output -> p (Either input a) (Either output a)
 *  | right :: forall input output a. p input output -> p (Either a input) (Either a output)
 *  | ```
 *  | If we specialize the profunctor `p` to the `function` arrow, we get the following type
 *  | signatures:
 *  | ```
 *  | left ::  forall input output a. (input -> output) -> (Either input a) -> (Either output a)
 *  | right :: forall input output a. (input -> output) -> (Either a input) -> (Either a output)
 *  | ```
 *  | When the `profunctor` is `Function` application, `left` allows you to map a function over the
 *  | left side of an `Either`, and `right` maps it over the right side (same as `map` would do).
 */
var right = function (dict) {
    return dict.right;
};

/**
 *  | The `Choice` class extends `Profunctor` with combinators for working with
 *  | sum types.
 *  |
 *  | `left` and `right` lift values in a `Profunctor` to act on the `Left` and
 *  | `Right` components of a sum, respectively.
 *  |
 *  | Looking at `Choice` through the intuition of inputs and outputs
 *  | yields the following type signature:
 *  | ```
 *  | left ::  forall input output a. p input output -> p (Either input a) (Either output a)
 *  | right :: forall input output a. p input output -> p (Either a input) (Either a output)
 *  | ```
 *  | If we specialize the profunctor `p` to the `function` arrow, we get the following type
 *  | signatures:
 *  | ```
 *  | left ::  forall input output a. (input -> output) -> (Either input a) -> (Either output a)
 *  | right :: forall input output a. (input -> output) -> (Either a input) -> (Either a output)
 *  | ```
 *  | When the `profunctor` is `Function` application, `left` allows you to map a function over the
 *  | left side of an `Either`, and `right` maps it over the right side (same as `map` would do).
 */
var left = function (dict) {
    return dict.left;
};

/**
 *  | Compose a value acting on a sum from two values, each acting on one of
 *  | the components of the sum.
 *  |
 *  | Specializing `(+++)` to function application would look like this:
 *  | ```
 *  | (+++) :: forall a b c d. (a -> b) -> (c -> d) -> (Either a c) -> (Either b d)
 *  | ```
 *  | We take two functions, `f` and `g`, and we transform them into a single function which
 *  | takes an `Either`and maps `f` over the left side and `g` over the right side.  Just like
 *  | `bi-map` would do for the `bi-functor` instance of `Either`.
 */
var splitChoice = function (dictCategory) {
    return function (dictChoice) {
        return function (l) {
            return function (r) {
                return Control_Semigroupoid.composeFlipped(dictCategory["__superclass_Control.Semigroupoid.Semigroupoid_0"]())(left(dictChoice)(l))(right(dictChoice)(r));
            };
        };
    };
};

/**
 *  | Compose a value which eliminates a sum from two values, each eliminating
 *  | one side of the sum.
 *  |
 *  | This combinator is useful when assembling values from smaller components,
 *  | because it provides a way to support two different types of input.
 *  |
 *  | Specializing `(|||)` to function application would look like this:
 *  | ```
 *  | (|||) :: forall a b c d. (a -> c) -> (b -> c) -> Either a b -> c
 *  | ```
 *  | We take two functions, `f` and `g`, which both return the same type `c` and we transform them into a
 *  | single function which takes an `Either` value with the parameter type of `f` on the left side and
 *  | the parameter type of `g` on the right side. The function then runs either `f` or `g`, depending on
 *  | whether the `Either` value is a `Left` or a `Right`.
 *  | This allows us to bundle two different computations which both have the same result type into one
 *  | function which will run the approriate computation based on the parameter supplied in the `Either` value.
 */
var fanin = function (dictCategory) {
    return function (dictChoice) {
        return function (l) {
            return function (r) {
                var join = Data_Profunctor.dimap(dictChoice["__superclass_Data.Profunctor.Profunctor_0"]())(Data_Either.either(Control_Category.id(Control_Category.categoryFn))(Control_Category.id(Control_Category.categoryFn)))(Control_Category.id(Control_Category.categoryFn))(Control_Category.id(dictCategory));
                return Control_Semigroupoid.composeFlipped(dictCategory["__superclass_Control.Semigroupoid.Semigroupoid_0"]())(splitChoice(dictCategory)(dictChoice)(l)(r))(join);
            };
        };
    };
};
var choiceFn = new Choice(function () {
    return Data_Profunctor.profunctorFn;
}, function (v) {
    return function (v1) {
        if (v1 instanceof Data_Either.Left) {
            return Data_Either.Left.create(v(v1.value0));
        };
        if (v1 instanceof Data_Either.Right) {
            return new Data_Either.Right(v1.value0);
        };
        throw new Error("Failed pattern match at Data.Profunctor.Choice line 33, column 3 - line 33, column 36: " + [ v.constructor.name, v1.constructor.name ]);
    };
}, Data_Functor.map(Data_Either.functorEither));
module.exports = {
    Choice: Choice, 
    fanin: fanin, 
    left: left, 
    right: right, 
    splitChoice: splitChoice, 
    choiceFn: choiceFn
};
