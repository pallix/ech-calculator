"use strict";
var Prelude = require("../Prelude");
var Data_Profunctor = require("../Data.Profunctor");
var Data_Tuple = require("../Data.Tuple");
var Data_Functor = require("../Data.Functor");
var Control_Semigroupoid = require("../Control.Semigroupoid");
var Control_Category = require("../Control.Category");

/**
 *  | The `Strong` class extends `Profunctor` with combinators for working with
 *  | product types.
 *  |
 *  | `first` and `second` lift values in a `Profunctor` to act on the first and
 *  | second components of a `Tuple`, respectively.
 *  |
 *  | Another way to think about Strong is to piggyback on the intuition of
 *  | inputs and outputs.  Rewriting the type signature in this light then yields:
 *  | ```
 *  | first ::  forall input output a. p input output -> p (Tuple input a) (Tuple output a)
 *  | second :: forall input output a. p input output -> p (Tuple a input) (Tuple a output)
 *  | ```
 *  | If we specialize the profunctor p to the function arrow, we get the following type
 *  | signatures, which may look a bit more familiar:
 *  | ```
 *  | first ::  forall input output a. (input -> output) -> (Tuple input a) -> (Tuple output a)
 *  | second :: forall input output a. (input -> output) -> (Tuple a input) -> (Tuple a output)
 *  | ```
 *  | So, when the `profunctor` is `Function` application, `first` essentially applies your function
 *  | to the first element of a `Tuple`, and `second` applies it to the second element (same as `map` would do).
 */
var Strong = function (__superclass_Data$dotProfunctor$dotProfunctor_0, first, second) {
    this["__superclass_Data.Profunctor.Profunctor_0"] = __superclass_Data$dotProfunctor$dotProfunctor_0;
    this.first = first;
    this.second = second;
};
var strongFn = new Strong(function () {
    return Data_Profunctor.profunctorFn;
}, function (a2b) {
    return function (v) {
        return new Data_Tuple.Tuple(a2b(v.value0), v.value1);
    };
}, Data_Functor.map(Data_Tuple.functorTuple));

/**
 *  | The `Strong` class extends `Profunctor` with combinators for working with
 *  | product types.
 *  |
 *  | `first` and `second` lift values in a `Profunctor` to act on the first and
 *  | second components of a `Tuple`, respectively.
 *  |
 *  | Another way to think about Strong is to piggyback on the intuition of
 *  | inputs and outputs.  Rewriting the type signature in this light then yields:
 *  | ```
 *  | first ::  forall input output a. p input output -> p (Tuple input a) (Tuple output a)
 *  | second :: forall input output a. p input output -> p (Tuple a input) (Tuple a output)
 *  | ```
 *  | If we specialize the profunctor p to the function arrow, we get the following type
 *  | signatures, which may look a bit more familiar:
 *  | ```
 *  | first ::  forall input output a. (input -> output) -> (Tuple input a) -> (Tuple output a)
 *  | second :: forall input output a. (input -> output) -> (Tuple a input) -> (Tuple a output)
 *  | ```
 *  | So, when the `profunctor` is `Function` application, `first` essentially applies your function
 *  | to the first element of a `Tuple`, and `second` applies it to the second element (same as `map` would do).
 */
var second = function (dict) {
    return dict.second;
};

/**
 *  | The `Strong` class extends `Profunctor` with combinators for working with
 *  | product types.
 *  |
 *  | `first` and `second` lift values in a `Profunctor` to act on the first and
 *  | second components of a `Tuple`, respectively.
 *  |
 *  | Another way to think about Strong is to piggyback on the intuition of
 *  | inputs and outputs.  Rewriting the type signature in this light then yields:
 *  | ```
 *  | first ::  forall input output a. p input output -> p (Tuple input a) (Tuple output a)
 *  | second :: forall input output a. p input output -> p (Tuple a input) (Tuple a output)
 *  | ```
 *  | If we specialize the profunctor p to the function arrow, we get the following type
 *  | signatures, which may look a bit more familiar:
 *  | ```
 *  | first ::  forall input output a. (input -> output) -> (Tuple input a) -> (Tuple output a)
 *  | second :: forall input output a. (input -> output) -> (Tuple a input) -> (Tuple a output)
 *  | ```
 *  | So, when the `profunctor` is `Function` application, `first` essentially applies your function
 *  | to the first element of a `Tuple`, and `second` applies it to the second element (same as `map` would do).
 */
var first = function (dict) {
    return dict.first;
};

/**
 *  | Compose a value acting on a `Tuple` from two values, each acting on one of
 *  | the components of the `Tuple`.
 *  |
 *  | Specializing `(***)` to function application would look like this:
 *  | ```
 *  | (***) :: forall a b c d. (a -> b) -> (c -> d) -> (Tuple a c) -> (Tuple b d)
 *  | ```
 *  | We take two functions, `f` and `g`, and we transform them into a single function which
 *  | takes a `Tuple` and maps `f` over the first element and `g` over the second.  Just like `bi-map`
 *  | would do for the `bi-functor` instance of `Tuple`.
 */
var splitStrong = function (dictCategory) {
    return function (dictStrong) {
        return function (l) {
            return function (r) {
                return Control_Semigroupoid.composeFlipped(dictCategory["__superclass_Control.Semigroupoid.Semigroupoid_0"]())(first(dictStrong)(l))(second(dictStrong)(r));
            };
        };
    };
};

/**
 *  | Compose a value which introduces a `Tuple` from two values, each introducing
 *  | one side of the `Tuple`.
 *  |
 *  | This combinator is useful when assembling values from smaller components,
 *  | because it provides a way to support two different types of output.
 *  |
 *  | Specializing `(&&&)` to function application would look like this:
 *  | ```
 *  | (&&&) :: forall a b c d. (a -> b) -> (a -> c) -> (a -> (Tuple b c))
 *  | ```
 *  | We take two functions, `f` and `g`, with the same parameter type and we transform them into a
 *  | single function which takes one parameter and returns a `Tuple` of the results of running
 *  | `f` and `g` on the parameter, respectively.  This allows us to run two parallel computations
 *  | on the same input and return both results in a `Tuple`.
 */
var fanout = function (dictCategory) {
    return function (dictStrong) {
        return function (l) {
            return function (r) {
                var split = Data_Profunctor.dimap(dictStrong["__superclass_Data.Profunctor.Profunctor_0"]())(Control_Category.id(Control_Category.categoryFn))(function (a) {
                    return new Data_Tuple.Tuple(a, a);
                })(Control_Category.id(dictCategory));
                return Control_Semigroupoid.composeFlipped(dictCategory["__superclass_Control.Semigroupoid.Semigroupoid_0"]())(split)(splitStrong(dictCategory)(dictStrong)(l)(r));
            };
        };
    };
};
module.exports = {
    Strong: Strong, 
    fanout: fanout, 
    first: first, 
    second: second, 
    splitStrong: splitStrong, 
    strongFn: strongFn
};
